"use strict";

var _extends2 = require("babel-runtime/helpers/extends");

var _extends3 = _interopRequireDefault(_extends2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _ = require(`lodash`);
var flatten = require(`flat`);
var typeOf = require(`type-of`);

var createKey = require(`./create-key`);

var _require = require(`./type-conflict-reporter`),
    typeConflictReporter = _require.typeConflictReporter;

var INVALID_VALUE = Symbol(`INVALID_VALUE`);
var isDefined = function isDefined(v) {
  return v != null;
};

var isEmptyObjectOrArray = function isEmptyObjectOrArray(obj) {
  if (obj === INVALID_VALUE) {
    return true;
  } else if (_.isDate(obj)) {
    return false;
    // Simple "is object empty" check.
  } else if (_.isObject(obj) && _.isEmpty(obj)) {
    return true;
  } else if (_.isObject(obj)) {
    return _.every(obj, function (value, key) {
      if (!isDefined(value)) {
        return true;
      } else if (_.isObject(value)) {
        return isEmptyObjectOrArray(value);
      } else {
        return false;
      }
    });
  }
  return false;
};

var isScalar = function isScalar(val) {
  return !_.isObject(val) || val instanceof Date;
};

var extractTypes = function extractTypes(value) {
  if (_.isArray(value)) {
    var uniqueTypes = _.uniq(value.filter(isDefined).map(function (item) {
      return extractTypes(item).type;
    })).sort();
    return {
      type: `array<${uniqueTypes.join(`|`)}>`,
      arrayTypes: uniqueTypes
    };
  } else {
    var type = typeOf(value);
    return {
      type,
      arrayTypes: []
    };
  }
};

var getExampleScalarFromArray = function getExampleScalarFromArray(values) {
  return _.reduce(values, function (value, nextValue) {
    // Prefer floats over ints as they're more specific.
    if (value && _.isNumber(value) && !_.isInteger(value)) {
      return value;
    } else if (value === null) {
      return nextValue;
    } else {
      return value;
    }
  }, null);
};

var extractFromEntries = function extractFromEntries(entries, selector) {
  var key = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

  var entriesOfUniqueType = _.uniqBy(entries, function (entry) {
    return entry.type;
  });

  if (entriesOfUniqueType.length == 0) {
    // skip if no defined types
    return null;
  } else if (entriesOfUniqueType.length > 1 || entriesOfUniqueType[0].arrayTypes.length > 1) {
    // there is multiple types or array of multiple types
    if (selector) {
      typeConflictReporter.addConflict(selector, entriesOfUniqueType);
    }
    return INVALID_VALUE;
  }

  // Now we have entries of single type, we can merge them
  var values = entries.map(function (entry) {
    return entry.value;
  });

  var exampleValue = entriesOfUniqueType[0].value;
  if (isScalar(exampleValue)) {
    return getExampleScalarFromArray(values);
  } else if (_.isObject(exampleValue)) {
    if (_.isArray(exampleValue)) {
      var concatanedItems = _.concat.apply(_, values);
      // Linked node arrays don't get reduced further as we
      // want to preserve all the linked node types.
      if (_.includes(key, `___NODE`)) {
        return concatanedItems;
      }

      return extractFromArrays(concatanedItems, entries, selector);
    } else if (_.isPlainObject(exampleValue)) {
      return extractFieldExamples(values, selector);
    }
  }
  // unsuported object
  return INVALID_VALUE;
};

var extractFromArrays = function extractFromArrays(values, entries, selector) {
  var filteredItems = values.filter(isDefined);
  if (filteredItems.length === 0) {
    return null;
  }
  if (isScalar(filteredItems[0])) {
    return [getExampleScalarFromArray(filteredItems)];
  }

  var flattenEntries = _.flatten(entries.map(function (entry) {
    return entry.value.map(function (value) {
      return (0, _extends3.default)({
        value,
        parent: entry.parent
      }, extractTypes(value));
    });
  }));

  return [extractFromEntries(flattenEntries, `${selector}[]`)];
};

/**
 * Takes an array of source nodes and returns a pristine
 * example that can be used to infer types.
 *
 * Arrays are flattened to either: `null` for empty or sparse arrays or a
 * an array of a sigle merged example. e.g:
 *
 *  - ['red'], ['blue', 'yellow'] -> ['red']
 *  - [{ color: 'red'}, { color: 'blue', ht: 5 }] -> [{ color: 'red', ht: 5 }]
 *
 * @param {*Nodes} args
 */
var extractFieldExamples = function extractFieldExamples(nodes, selector) {
  // get list of keys in all nodes
  var allKeys = _.uniq(_.flatten(nodes.map(_.keys)));

  return _.zipObject(allKeys, allKeys.map(function (key) {
    var nextSelector = selector && `${selector}.${key}`;

    var nodeWithValues = nodes.filter(function (node) {
      if (!node) return false;

      var value = node[key];
      if (_.isObject(value)) {
        return !isEmptyObjectOrArray(value);
      } else {
        return isDefined(value);
      }
    });

    // we want to keep track of nodes as we need it to get origin of data
    var entries = nodeWithValues.map(function (node) {
      var value = node[key];
      return (0, _extends3.default)({
        value,
        parent: node
      }, extractTypes(value));
    });

    return extractFromEntries(entries, nextSelector, key);
  }));
};

var buildFieldEnumValues = function buildFieldEnumValues(arg) {
  var enumValues = {};
  var values = flatten(getExampleValues(arg), {
    maxDepth: 3,
    safe: true, // don't flatten arrays.
    delimiter: `___`
  });
  Object.keys(values).forEach(function (field) {
    if (values[field] == null) return;
    enumValues[createKey(field)] = { field };
  });

  return enumValues;
};

// extract a list of field names
// nested objects get flattened to "outer___inner" which will be converted back to
// "outer.inner" by run-sift
var extractFieldNames = function extractFieldNames(arg) {
  var values = flatten(getExampleValues(arg), {
    maxDepth: 3,
    safe: true, // don't flatten arrays.
    delimiter: `___`
  });

  return Object.keys(values);
};

var typeExampleValues = {};

var clearTypeExampleValues = function clearTypeExampleValues() {
  typeExampleValues = {};
  typeConflictReporter.clearConflicts();
};

var getNodesAndTypeFromArg = function getNodesAndTypeFromArg(arg) {
  var type = void 0,
      nodes = void 0;

  if (_.isPlainObject(arg)) {
    type = arg.type;
    nodes = arg.nodes;
  } else if (_.isArray(arg)) {
    nodes = arg;
    if (nodes.length > 0 && nodes[0].internal) {
      type = nodes[0].internal.type;
    }
  } else if (_.isString) {
    type = arg;
  }

  return { type, nodes };
};

var getExampleValues = function getExampleValues(arg) {
  var _getNodesAndTypeFromA = getNodesAndTypeFromArg(arg),
      type = _getNodesAndTypeFromA.type,
      nodes = _getNodesAndTypeFromA.nodes;

  // if type is defined and is in example value cache return it


  if (type && type in typeExampleValues) {
    return typeExampleValues[type];
  }

  // if nodes were passed extract field example from it
  if (nodes && nodes.length > 0) {
    var exampleValue = extractFieldExamples(nodes, type);
    // if type is set - cache results
    if (type) {
      typeExampleValues[type] = exampleValue;
    }
    return exampleValue;
  }

  return {};
};

module.exports = {
  INVALID_VALUE,
  buildFieldEnumValues,
  extractFieldNames,
  isEmptyObjectOrArray,
  clearTypeExampleValues,
  getExampleValues
};
//# sourceMappingURL=data-tree-utils.js.map